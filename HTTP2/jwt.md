## 널리 쓰이는 JWT 서명 알고리즘

- HMAC + SHA256
- RSASSA-PKCS1-v1_5 + SHA256
- ECDSA + P-256 + SHA256

자세한 사양은 [RFC 7518](https://tools.ietf.org/html/rfc7518#section-3)에서 찾아볼 수 있다.

### HMAC 알고리즘

HMAC는 JWT를 서명할 때 가장 많이 쓰이는 알고리즘이다.

HMAC(Hash-Based Message Authentication Codes)은 공유키를 사용하여 메시지에 서명하는 방법을 제공하는 알고리즘 그룹이다. HMAC은 SHA256 같은 암호화 해시 함수를 사용한다. 강도(즉, HMAC를 위조하는 게 얼마나 힘든가)는 사용하는 해싱 알고리즘에 따라 다르다.

알고리즘 설계의 주요 목적은 키와 메시지의 결합을 허용하면서 변조 방지를 강력하게 보장하는 것에 있었다. Ad-hoc solutions (for example, appending the key to the message and then hashing the result) suffer from mathematical flaws that allow potential attackers to forge the signature. HMAC 알고리즘은 이를 위해 설계 됐다.

The algorithm per-se is quite simple (JavaScript pseudo-code with Node.js extensions):

```javascript
// Key: Buffer with key, Message: Buffer with message
function hmacSha256(key, message) {
    // The algorithm requires the key to be of the same length as the
    // "block-size" of the hashing algorithm (SHA256 = 64-byte blocks).
    // Extension is performed by appending zeros.
    var fullLengthKey = extendOrTruncateKey(key);

    var outterKeyPad = 0x5c; // A constant defined by the spec.
    var innerKeyPad = 0x36; // Another constant defined by the spec.

    var outterKey = new Buffer(fullLengthKey.length);
    var innerKey = new Buffer(fullLengthKey.length);
    for(var i = 0; i < fullLengthKey.length; ++i) {
        outterKey[i] = outterKeyPad ^ fullLengthKey[i];
        innerKey[i] = innerKeyPad ^ fullLengthKey[i];
    }

    // sha256(outterKey + sha256(innerKey, message))
    // (Buffer.concat makes this harder to read)
    return sha256(Buffer.concat([outterKey, sha256(Buffer.concat([innerKey, message]))]));
}
```

모든 동료들이 JWT를 작성하고 검증할 수 있는 간편한 방법이 필요할 때, HMAC이 함께 사용될 수 있다. 누구든 키를 알고 있다면 새로운 JWT를 작성할 수 있다. 다시 말해, 공유키를 가지고 있다면 다른 사람을 가장할 수 있다. HMAC JWT는 JWT 작성자가 누군지 보증해주지 않는다. 상황에 따라서 너무 관대한 정책일 수 있다. 비대칭 알고리즘이 필요한 순간이다.

### RSA, ECDSA 알고리즘

RSA와 ECDSA는 비대칭 암호화 및 디지털 서명 알고리즘이다. What asymmetric algorithms bring to the table is the possibility of verifying or decrypting a message without being able to create a new one. This is key for certain use cases. Picture a big company where data generated by the sales team needs to be verified by the accounting team. If an HMAC were to be used to sign the data, then both the sales team and the accounting team would need to know the same key. This would allow the sales team to sign data and make it pass as if it were from the accounting team. Although this might seem unlikely, especially in the context of a corporation, there are times when the ability to verify the creator of a signature is essential. JWTs signed or encrypted with RSA or ECDSA provide this capability. A party uses its private party to sign a JWT. Receivers in turn use the public key (which must be shared in the same way as an HMAC shared key) of that party to verify the JWT. The receiving parties cannot create new JWTs using the public key of the sender.

Both RSA and ECDSA algorithms are more complex than HMAC. If you are interested in the gritty details, read [RFC 3447](https://tools.ietf.org/html/rfc3447) for RSA encryption, and the original [ECDSA paper](http://cs.ucsb.edu/~koc/ccs130h/notes/ecdsa-cert.pdf).

The main difference between RSA and ECDSA lies in speed and key size. ECDSA requires smaller keys to achieve the same level of security as RSA. This makes it a great choice for small JWTs. RSA, however, is usually faster than ECDSA. As usual, pick the one that best aligns with your requirements.

## 참고

https://auth0.com/blog/json-web-token-signing-algorithms-overview/